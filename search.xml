<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F01%2F15%2Fnpm%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[npm模块开发问题总结简介：总结在开发 npm 模块过程遇到的一些问题 #专业技能 目录 LICENSE 导出模块 命名冲突 LICENSE在初始化 npm 时需要指定开源协议，当时还各种找模板，其实在 github 创建新的仓库时就可以指定生成了，也有 简单的介绍 导出模块在导出 npm 模块时，一开始我很天真的使用 ES6 的语法（还没被实现的语法，我怎么想的，真是笑死我了）1export default myFunction 再了解到 Webpack 同时支持 CommonJS 和 AMD 方案后，决定使用 AMD 方案。结果 create-react-app 又不支持 AMD 所以最后使用了 UMD 的 returnExports 兼 Node, AMD 和 browser globals 3 种使用方式，顺便整理了 JS 模块的规范： AMDRequireJS使用的方案12345678// define暴露define(function() &#123; // 返回想要暴露的对象 return objectYourWantToExport&#125;)// require引入require([module], callback) CommonJSNodeJS使用的方案12345// exports暴露module.exports = jquery// require引入var $ = require('jquery') UMD通用模块规范UMD github 命名冲突在发布 npm 模块时出现错误，还以为是哪一步错了，结果时包的命名冲突了，更改 package.json 中的 name 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm模块开发问题总结]]></title>
      <url>%2F2017%2F01%2F15%2Fnpm-module%2F</url>
      <content type="text"><![CDATA[简介：总结在开发 npm 模块过程遇到的一些问题 目录 LICENSE 导出模块 命名冲突 LICENSE在初始化 npm 时需要指定开源协议，当时还各种找模板，其实在 github 创建新的仓库时就可以指定生成了，也有 简单的介绍 导出模块在导出 npm 模块时，一开始我很天真的使用 ES6 的语法（还没被实现的语法，我怎么想的，真是笑死我了）1export default myFunction 再了解到 Webpack 同时支持 CommonJS 和 AMD 方案后，决定使用 AMD 方案。结果 create-react-app 又不支持 AMD 所以最后使用了 UMD 的 returnExports 兼 Node, AMD 和 browser globals 3 种使用方式，顺便整理了 JS 模块的规范： AMDRequireJS使用的方案12345678// define暴露define(function() &#123; // 返回想要暴露的对象 return objectYourWantToExport&#125;)// require引入require([module], callback) CommonJSNodeJS使用的方案12345// exports暴露module.exports = jquery// require引入var $ = require('jquery') UMD通用模块规范UMD github 命名冲突在发布 npm 模块时出现错误，还以为是哪一步错了，结果时包的命名冲突了，更改 package.json 中的 name 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性访问检测]]></title>
      <url>%2F2017%2F01%2F08%2Fsnooper%2F</url>
      <content type="text"><![CDATA[简介：发现定义 Object.defineProperty 的 getter 方法可以做很有意思的事，适合做浏览器的兼容性检测，特此记录一下 事情是这样的，为了优化浏览器的滚动体验， addEventListener 的第三个参数可以传一个包含 passive 属性的对象，表明该事件是 passive 的（具体可以看Passive Event Listener）。但是为了兼容旧版本的浏览器，就需要探测浏览器浏览器是否接受一个包含 passive 属性的对象。那么怎么探测呢？具体代码如下12345678910111213// Test via a getter in the options object to see if the passive property is accessedvar supportsPassive = false;try &#123; var opts = Object.defineProperty(&#123;&#125;, 'passive', &#123; get: function() &#123; supportsPassive = true; &#125; &#125;); window.addEventListener("test", null, opts);&#125; catch (e) &#123;&#125;// Use our detect's results. passive applied if supported, capture will be false either way.elem.addEventListener('touchstart', fn, supportsPassive ? &#123; passive: true &#125; : false); 自定义对象的属性和 getter 方法，如果被检测的函数使用了该属性，那么必定会调用 getter 方法，这样就能判断浏览器是是支持该特性的，真是巧妙到没有朋友啊！ 总结 使用场景：检测是否访问过对象的某属性 使用方法：通过 Object.defineProperty 自定义 getter 方法来检测 原理：如果访问该属性，则会调用 getter 方法 自测题目 检测函数 say 是否支持接受 name 属性和 test 属性123function say(person) &#123; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; old`)&#125; 答案12345678910111213141516171819202122232425function say(person) &#123; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; old`)&#125;let isSupportName = falsetry &#123; const snooper = Object.defineProperty(&#123;&#125;, 'name', &#123; get() &#123; isSupportName = true &#125; &#125;) say(snooper)&#125;catch(e) &#123;&#125;let isSupportTest = falsetry &#123; const snooper = Object.defineProperty(&#123;&#125;, 'test', &#123; get() &#123; isSupportTest = true &#125; &#125;) say(snooper)&#125;catch(e) &#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手Q演出选座页性能10倍提升的优化]]></title>
      <url>%2F2017%2F01%2F02%2Fcanvas-seat%2F</url>
      <content type="text"><![CDATA[简介：本文将会分析在使用React时，面对多组件（如1K个组件）的初始化渲染，和单组件更新的场景，可以使用的优化思路 目录 前提 场景 Single Connect 方案 Multiple Connect 方案 Smart Seat 方案 Canvas Seat 方案 总结 前提 本文测试时所使用库的版本如下1234567891011"dependencies": &#123; "classnames": "^2.2.5", "react": "^15.4.0", "react-dom": "^15.4.0", "react-redux": "^4.4.6", "react-router": "^3.0.0", "redux": "^3.6.0", "redux-logger": "^2.7.4", "redux-thunk": "^2.1.0", "reselect": "^2.5.4"&#125; 场景在我们演出项目的选座页，需要展示演出的座位，并且在用户选择某一座位后，要更新该座位的视图。为了简化问题，在这里抽象一下模型，即有 Seats 和 Seat 两个组件 Seats 从 store 中接收一个包含 1000 个包含座位信息的 seat 元素的数组 seats ，然后渲染 Seat 组件 Seat 组件被点击后，变更该组件颜色 Single Connect 方案Single Connect方案 ，这是我们最开始的方案，只在 Seat 组件内定义 shouldComponentUpdate 减少不必要的 render 性能及分析 iphone7 小米 初始渲染时间 40ms 474ms 组件更新时间 70ms 123ms 此时性能瓶颈主要有 2 点：每次更新时 Seats 组件都需要渲染；数据需要从 store 经过 Seats 最终才能传递给对应的 Seat 组件。后面优化也是针对这 2 点进行的 Multiple Connect 方案Multiple Connect方案是参考 Dan 神提出的 分离数据 思想，来减少不必要的 render 实现思想：在每次更新时，其实 Seats 是不需要 render 的，真正需要 render 的只有那个被点击的 Seat 实现方式： Seats 组件只关心要渲染多少个 Seat 组件，即从 seats 数组中分离出 seatIds 表示每个元素的 index，然后 Seats 组件根据 seatIds 来 map，注意因为每次更新 seatIds 是不会变的，所以可以 减少 Seats 的渲染 Seat 组件只关心自己的状态，Seat 组件也 connect store，并且根据 Seats 传进来的 id 来从 seats 数组中获得自己对应的 seat 数据 性能及分析 iphone7 小米 初始渲染时间 103ms 1700ms 组件更新时间 8ms (8x) 17ms (7x) 组件更新性能平均提升了7x左右，因为此时减少了 Seats 组件的渲染，且数据直接从 store 通过 connect 传递给对应的 Seat 组件。但是 Seat 组件需要在初始化时 subscribe store，所以增加了初始渲染时间 Smart Seat 方案Smart Seat方案的主要思想是：把 Seat 由单纯的展示型组件，变成功能型组件，由每个 Seat 来管理自己的状态 实现方式如下：在 Seat 组件被点击时，dispatch action 然后在回调里 setState 触发组件更新12345678onClick = id =&gt; &#123; this.props.selectSeat(id) .then(selectSuccess =&gt; &#123; this.setState(&#123; selected: selectSuccess, &#125;) &#125;)&#125; 性能及分析 iphone7 小米 初始渲染时间 41ms 478ms 组件更新时间 9ms (8x) 5ms (24x) 此时不但减少 Seats 组件的渲染，且数据也绕过 store 直接从 actions 的回调中获得，使得组件更新性能平均提升了 16x 左右 Canvas Seat 方案Canvas Seat方案的思想是使用 canvas 来绘制座位和更新对应座位，这样就可以不用渲染那么多 Seat 节点，只渲染一个 canvas 节点即可，规避 dom 慢的缺陷。且更新不发生 render，只是重绘对应位置的座位，省去 Seats 组件的渲染 实现方式：在 Seats 组件只 render 一个 canvas 节点，并在 componentDidMount 后绘制座位 性能及分析 iphone7 小米 初始渲染时间 4.3ms (9x) 42ms (12x) 组件更新时间 3.7ms (18x) 10ms (12x) 初始时减少大量节点的渲染，初始化性能惊人的提升了 10x。更新组件时，也只是重新绘制一个座位，组件更新性能也得到了极大的 18x的提升 总结在摸索 React 性能优化的过程中，越发的理解前端的性能瓶颈不在 JS，而在 dom 的操作。我曾尝试过各种方法减少数组的遍历，更高效的取整（ ~~ 替代 parseInt ），但效果都是微乎其微。而每一次减少组件的 render，却能给性能带来成倍的提升，如 Multiple Connect 和 Smart Seat 方案中，减少 Seats 组件的渲染带来了 5x 的提升。Canvas Seat 方案中，减少了 999 个组件的渲染（1 个 canvas 代替 1000 个 Seat ），带来 10x 的性能提升！ 而且，另一个让我感受很深的就是，除了 Multiple Connect 方案是根据 Dan 神提出的思想实现的，其余 2 个方案都是我们手Q队员提出的，而且性能都比 Dan 神的方案好！这让我学习到，作为一个程序员，能因地制宜，发挥自己的 想象力 提出更针对性的方案更重要]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原型继承]]></title>
      <url>%2F2016%2F12%2F31%2Fprototype-inheritance%2F</url>
      <content type="text"><![CDATA[简介：学习原型继承的原理 目录 术语 原型继承的使用场景 原型继承的使用方法 原理 术语 Constructor：泛指构造函数 Class：泛指类 instance：泛指实例 原型对象：prototype属性的值 使用场景想要使对象拥有 新属性 ，而该属性是在其原型链上的若不介意是在其原型链上，还是在其本身，则为该对象赋值即可 使用方法 用new关键字调用构造函数，使实例原型继承该构造函数 12345function Person() &#123;&#125;Person.prototype.sayHi = function ()&#123;&#125;// person原型继承Personconst person = new Person()console.log(person.sayHi) 用extends关键字，使一个类原型继承另一个类 1234567891011class Person &#123; sayHi() &#123;&#125;&#125;// Student原型继承Personclass Student extends Person &#123; study() &#123;&#125;&#125;// student原型继承Studentconst student = new Student()console.log(student.sayHi)console.log(student.study) 原理在了解原理前，先了解2个关键的知识点：prototyoe属性，和proto属性 prototype属性prototype属性只存在于构造函数的属性中，其值为一个对象，该对象用于储存其所有实例共享的属性和方法。（以后称该对象为原型对象） 类比：只有一代宗师（构造函数），才有用于记录自己招式的武功秘籍（原型对象），而其所有徒弟（实例），都能访问到武功秘籍上的招式（属性） proto属性proto属性存在于每个对象中，值为该对象的原型好吧，其实null对象没有proto属性，但咱先忽略 类比：每个人（对象），都有一条链子（proto）。链子的另一端，绑着其师傅（构造函数）的武功秘籍（原型对象） 原型继承原理访问对象的属性时，如果在对象上找不到指定属性，则不断在对象的proto上查找，一直到原型链最顶层都没找到，则返回undefined 假设当前实例为instance，在instance上找不到，则会在instance.proto上找，再找不到，则在instance.proto.proto上找，一直到Object.prototype.proto也就是null都没找到，则返回undefined 题外话在JavaScript世界中。构造函数Object原型继承null，Function原型继承Object，最后Function实例出能实例千千万的构造函数function。12345678910console.log(Object.prototype.__proto__ === null)// true, Object继承nullconsole.log(Function.prototype.__proto__ === Object.prototype)// true，构造函数Function继承Objectfunction P()&#123;&#125;console.log(P.__proto__ === Function.prototype)// true，构造函数P，是构造函数Function的实例const p = new P()console.log(p.__proto__ === P.prototype)// true，实例p，是构造函数P的实例 实例原型继承构造函数的原理在使用new关键字调用构造函数时，JS自动把实例的proto属性指向构造函数的prototype对象1234567function Person() &#123;&#125;const person = new Person()// 等价于function Person() &#123; // this.__proto__ = Person.prototype // return this&#125; 构造函数继承构造函数的原理123class Student extends Person &#123;&#125;// 等价于Student.prototype.__proto__ = Person.prototype]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构造函数]]></title>
      <url>%2F2016%2F12%2F25%2Fconstructor%2F</url>
      <content type="text"><![CDATA[简介：本文介绍了构造函数，构造函数的prototype属性，构造函数的prototype.constructor属性的应用场景和使用方式。在ES6新增的类的对应使用方式 目录 术语 构造函数 prototype属性 constructor属性 类 总结 自测题目 术语 Constructor：构造函数 instance：实例 构造函数:ConstructorJavaScript中用new关键字调用的就是构造函数123456789function Person(age) &#123; this.age = age this.say = function() &#123; // 实例能访问this.age，this就是实例自己 console.log(`My age is $&#123;this.age&#125;`) &#125;&#125;const p = new Person(18)p.say() 原理：使用new调用构造函数时，其函数体定义的this会默认返回作为实例 应用场景：定义私有属性和方法 使用方式：在构造函数的函数体内的this定义。如上所示，为this定义age属性和say方法，即可使其实例拥有对应的私有属性和方法 prototype属性：Constructor.prototype每个构造函数都有一个prototype属性，其值为一个对象（以后称prototype所指的对象为原型对象） 原型对象的用途，是储存其所有实例共享的属性和方法。《JavaScript高级程序设计》P147 12345678function Person() &#123;&#125;Person.prototype.age = 18Person.prototype.say = function() &#123; // 实例能访问this.age，是因为age是实例的原型属性，在其原型链上 console.log(`My age is $&#123;this.age&#125;`)&#125;const p = new Person()p.say() 原理：实例继承构造函数的原型对象，所以能通过原型链访问 应用场景：定义共享属性和方法 使用方式：在构造函数的原型对象上定义。如上所示，为Person.prototype定义age属性和say方法，即可使所有实例都拥有对应的共有属性和方法 constructor属性：Constructor.prototype.constructor 所有原型对象都会自动获得一个constructor属性，指向prototype属性所在的构造函数。《JavaScript高级程序设计》P148 12345678function Person() &#123;&#125;Person.age = 18Person.say = function() &#123; // 注意，此时还能用this，访问this.age console.log(`My age is $&#123;this.age&#125;`)&#125;const p = new Person()p.constructor.say() 原理：构造函数也是对象，能定义自己的属性和方法（称为静态属性和方法） 应用场景：定义默认属性，如React的defaultProps。和校验方法如Array.isArray 使用方式：直接在构造函数这个对象上定义。如上所示Person.name，然后调用时通过p.constuctor.say。因为实例是继承构造函数的原型对象，而不是继承构造函数 类ES6新增了class关键字，允许我们定义类。但其实class只是构造函数的语法糖而已123456789101112class Person &#123; // 等价于Person.staticSay = function()&#123;&#125; static staticSay() &#123;&#125; constructor(age) &#123; this.age = age // 等价于this.instanceSay = function()&#123;&#125; this.instanceSay = function()&#123;&#125; &#125; // 等价于Person.prototype.prototypeSay = function()&#123;&#125; prototypeSay() &#123;&#125;&#125;const p = new Person() 其中加了static关键字的方法，相当于构造函数的静态方法，constructor相当于构造函数的函数体，而非constructor的其余方法，则相当于构造函数的原型方法 总结 Constructor的函数体是定义实例的实例属性和方法的 Constructor.prototype是定义实例的共享属性和方法的 Constructor上是定义构造器的静态属性和方法的 类知识构造函数的语法糖 自测题目 声明一个构造函数Student，使得该构造函数产生的实例 有私有的name属性和study方法 有共有的school属性和say方法 有静态属性defaultProps和用于校验是否Student实例的isStudent方法 使用类完成上述功能 答案123456789101112131415161718192021function Student(name) &#123; this.name = name this.study = function() &#123; console.log('unique study method') &#125;&#125;Student.prototype.shcool = 'MIT'Student.prototype.say = function() &#123; console.log('common say method')&#125;Student.defaultProps = 'student'Student.isStudent = function(instance) &#123; return instance instanceof Student&#125;const joe = new Student('joe')console.log(joe.name) // joejoe.study() // unique study methodconsole.log(joe.shcool) // MITjoe.say() // common say methodconsole.log(Student.isStudent(joe)) // true]]></content>
    </entry>

    
  
  
</search>
