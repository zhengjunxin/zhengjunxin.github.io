<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[为什么 React 需要 Redux 这类状态管理库]]></title>
      <url>%2F2017%2F06%2F22%2Fwhy-need-state-management%2F</url>
      <content type="text"><![CDATA[简介：用生动形象的例子总结为什么 React 需要 Redux 这类状态管理库 在开始用 Redux 时，只知道 Redux 是用来管理状态的，很吊，大家都用他，所以就用了。对于状态指的是什么？为什么需要 Redux 来管理状态？其实我并不是很清楚。现在空闲下来，所以思考一下为什么 React 需要 Redux 这类状态管理库呢？我个人总结出的答案是为了方便组件间的通信，在 React 中，父组件向子组件通信很容易，但对祖父向孙子，子向父，兄弟组件间的通信则比较麻烦。而在大型的应用，这 3 种场景是无法避免的，所以需要借助 Redux 来解决这个问题。且容我用一个生动形象的例子解释一下。 父组件与子组件通信假设我们需要实现一个类似购物车页面，我们的代码大概会是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const Goods = (&#123; goods, increment, decrement &#125;) =&gt; ( &lt;div&gt; &#123; goods.map(good =&gt; ( &lt;div&gt; &#123;good.name&#125; &#123;good.number&#125; &lt;button onClick=&#123;() =&gt; increment(good.id)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; decrement(good.id)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )) &#125; &lt;/div&gt;)class Shop extends React.Component &#123; state = &#123; goods: [ &#123; id: 0, name: 'iphone', number: 0 &#125;, &#123; id: 1, name: 'mbp', number: 0 &#125;, ] &#125; render() &#123; return ( &lt;div className="App"&gt; &lt;Goods goods=&#123;this.state.goods&#125; increment=&#123;this.increment&#125; decrement=&#123;this.decrement&#125; /&gt; &lt;/div&gt; ) &#125; increment = (goodId) =&gt; &#123; this.updateGoods(goodId, true) &#125; decrement = (goodId) =&gt; &#123; this.updateGoods(goodId, false) &#125; updateGoods(goodId, isIncrement) &#123; this.setState(&#123; goods: this.state.goods.map(good =&gt; &#123; if (good.id === goodId) &#123; return Object.assign(&#123;&#125;, good, &#123; number: isIncrement ? good.number + 1 : good.number - 1, &#125;) &#125; return good &#125;) &#125;) &#125;&#125; Shop 组件负责维护数据 goods 和对应的更新方法 increment 和 decrement，而 Goods 组件负责展示商品，所以只需要 Shop 把 goods 和 increment, decrement 传递给其子组件 Goods 即可，即父组件 Shop 通过传递 props 给子组件 Goods，实现父子组件间的通信。但是随着功能的增多，我们可能需要把商品单独分出一个组件来，这样一来我们就需要实现祖父组件与孙子组件间的通信了 祖父组件与孙子组件间的通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const Good = (&#123; good, increment, decrement &#125;) =&gt; ( &lt;div&gt; &#123;good.name&#125; &#123;good.number&#125; &lt;button onClick=&#123;() =&gt; increment(good.id)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; decrement(good.id)&#125;&gt;-&lt;/button&gt; &lt;/div&gt;)const Goods = (&#123; goods, increment, decrement &#125;) =&gt; ( &lt;div&gt; &#123; goods.map(good =&gt; &lt;Good key=&#123;good.id&#125; good=&#123;good&#125; increment=&#123;increment&#125; decrement=&#123;decrement&#125; /&gt;) &#125; &lt;/div&gt;)class Shop extends React.Component &#123; state = &#123; goods: [ &#123; id: 0, name: 'iphone', number: 0 &#125;, &#123; id: 1, name: 'mbp', number: 0 &#125;, ] &#125; render() &#123; return ( &lt;div className="App"&gt; &lt;Goods goods=&#123;this.state.goods&#125; increment=&#123;this.increment&#125; decrement=&#123;this.decrement&#125; /&gt; &lt;/div&gt; ) &#125; increment = (goodId) =&gt; &#123; this.updateGoods(goodId, true) &#125; decrement = (goodId) =&gt; &#123; this.updateGoods(goodId, false) &#125; updateGoods(goodId, isIncrement) &#123; this.setState(&#123; goods: this.state.goods.map(good =&gt; &#123; if (good.id === goodId) &#123; return Object.assign(&#123;&#125;, good, &#123; number: isIncrement ? good.number + 1 : good.number - 1, &#125;) &#125; return good &#125;) &#125;) &#125;&#125; 此时就需要把 goods 和 increment, decrement，从祖父组件 Shop 传递给父组件 Goods，再传递给 Good。这时就能发现，这样传递有点麻烦了，不过还在可接受范围内。但是，随着规模的增加，说不定会出现曾曾祖父组件与其曾曾孙组件的通信，这样层层传递数据就会显得很头疼。 Redux 的通信方式借助 Redux 这类状态管理库，通过定义 store，在需要的组件调用 connect 即可访问指定的数据（如 goods ）和对应的更新数据的 dispatch 方法。只要简单的一个 connect，无论是曾孙组件还是玄孙组件，都能马上访问到数据，免去层层传递的麻烦！ 1export default connect(state =&gt; (&#123; goods: state.goods &#125;))(Goods) 总结状态管理库中所谓的状态，即用于渲染视图的数据。而 React 需要 Redux, Mobx 这类状态管理库，是为了更方便组件间的通信。无论组件的层级关系是祖父与孙子、曾祖父与曾孙子，只需要 connect 即可获取数据，和更新数据的方法，而不用层层传递。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas 绘制问题总结]]></title>
      <url>%2F2017%2F05%2F26%2Fcanvas-problems%2F</url>
      <content type="text"><![CDATA[简介：本文将会介绍在使用 canvas 过程中遇到的问题 遇到的问题 模糊问题 IOS上 canvas 尺寸限制问题 模糊问题模糊问题主要是 canvas 绘制到高清屏上时，被拉伸导致的。 举个简单的例子就是：一个 200200 的 canvas，渲染在设备像素比为 1 的设备上，正常渲染，所以正常显示。但是在设备像素比为 2 的设备上，则需要 400400 像素才能正常显示，现在只有 200*200 所以 canvas 被拉伸导致模糊了。 解决办法就是绘制 devicePixelRatio 倍的 canvas。比如设备像素比为 2，只要绘制 400400 大小的 canvas，再定义样式缩小为 200200。这样最终绘制时，即使被拉伸为 400400，但 canvas 本身就是 400400 所以就能正常显示啦~ 代码如下：123456789const width = 200const height = 200const ratio = window.devicePixelRatio || 1canvas.width = width * ratiocanvas.height = height * ratioctx.scale(ratio, ratio)canvas.style.width = `$&#123;width&#125;px`canvas.style.height = `$&#123;height&#125;px` IOS上 canvas 尺寸限制问题描述问题 IOS 上对 canvas 的尺寸有限制，超过限定尺寸后调用绘制方法不会绘制到 canvas 上，但不报错！ 尺寸是指 canvas 的宽高，而不是样式宽高。即 canvas.width 而不是 canvas.style.width 限制是针对面积的，而且随 IOS 版本变化的，IOS9 以下最大允许 2096 2096 的 canvas，IOS9以上最大允许 4096 4096 解决思路1绘制失败属于少见的异常场景，所以可以先绘制，再探测是否绘制成功，如果失败，则降低清晰度再绘制。这样能保证在大部分的正常场景能较快的完成绘制，小部分的异常场景绘制慢一点而已。 经过搜索，有 2 种方式可以探测是否绘制成功 toDataURL getImageData 结果：在小米Note 上探测是否绘制成功会闪退。详细情况是：小米支持 1600016000 尺寸的 canvas，但是在 70007000 尺寸以上调用 toDataURL 就会闪退，在 8500*8500 尺寸以上调用 getImageData 就会闪退。所以该方案失败！ 解决思路2发现安卓对 canvas 的限制比较松，如小米Note能支持到 16000*16000 的尺寸。所以可以检测设备机型，如果是安卓则正常绘制，如果是 IOS 则根据版本进行 canvas 缩放。保证不超过该版本允许的尺寸。 结果：在 IOS7 上绘制的尺寸临近但不超过 2096*2096 能成功绘制，但是会出现 canvas 中间莫名空白一块的奇异问题。所以该方案最终失败。 结论IOS 上绘制大屏的 canvas 暂时只能通过绘制多个 canvas 实现 参考High DPI CanvasMaximum size image on Safari page]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[debounce 和 throttle 总结]]></title>
      <url>%2F2017%2F03%2F17%2Fdebounce-and-throttle%2F</url>
      <content type="text"><![CDATA[简介：介绍 debounce 和 throttle 的区别和使用场景 为什么需要节流函数某些操作(如：输入监听、滚动监听)，会在短时间内频繁调用函数，造成页面卡顿。所以这时就需要节流函数来减少函数的调用频率，优化体验。但是节流函数可以分为防抖动(debounce)，节流(throttle)两种，那什么时候用防抖动，什么时候用节流呢？ debounce 函数debounce 把多个连续的函数调用汇总起来，然后在最后一次调用后触发。 联想：debounce 防抖动，尿完尿之后，才抖一下，而且只抖一下使用场景： 输入监听，最后一次输入才是有效的输入 throttle 函数throttle 限制函数调用，在固定时间内只会触发一次 联想：throttle 节流器，掐紧水管，固定的时间只能滴一滴使用场景： 滚动监听，此时不能用 debounce 因为他会在停下来时才触发 总结debounce 是在多次函数调用，但只有一次是有效时使用。throttle 是在多次函数调用且都有效，但需要减少频率时使用。或者说只需要抖一抖时用 debounce 函数，其余的就用 throttle 函数。 参考debouncing-throttling-explained-examples函数节流和函数去抖应用场景辨析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件循环]]></title>
      <url>%2F2017%2F03%2F08%2Fevent-loop%2F</url>
      <content type="text"><![CDATA[简介：学习事件循环的 macrotask 和 microtask 和抛出异常后 JS 引擎的工作 事件循环12345678910111213setTimeout(function()&#123;console.log(4)&#125;,0);new Promise(function(resolve)&#123; console.log(1) for( var i=0 ; i&lt;10000 ; i++ )&#123; i==9999 &amp;&amp; resolve() &#125; console.log(2)&#125;).then(function()&#123; console.log(5)&#125;);console.log(3);// 1 2 3 5 4 浏览器只有一个事件循环（Event Loop），但可以有多个队列，每个队列的优先级不一样。浏览器先执行一个 macrotask，然后执行所有 microtask macrotask 队列：整个脚本，setTimeout microtask 队列：then 整个脚本在 macrotask setTimeout 推入 macrotask console.log(1) resolve 导致 then 推入 microtask console.log(2) console.log(3) 脚本执行完成毕，执行 microtask console.log(5) 执行下一个 macrotask console.log(4) 异常12345678910setTimeout(() =&gt; &#123; console.log(23333)&#125;, 0)throw "Error"// 结果 // Uncaught Error// 23333// 而不是 Uncaught Error 后就不响应了 异常只是从当前函数中退出，但是引擎会继续工作（以前还以为抛出异常后，引擎就不响应了呢）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《白帽子讲 Web 安全》总结]]></title>
      <url>%2F2017%2F02%2F28%2Fweb-security%2F</url>
      <content type="text"><![CDATA[简介：介绍XSS（跨站脚本攻击）、CSRF (跨站请求伪造)和原理、应用和防御 XSS（跨站脚本攻击）使用场景 cookie劫持 模拟请求：删文章，发评论等 钓鱼：画出登录窗口，让用户输入密码 利用扩展程序、浏览器控件 防御方法 httpOnly 防御 XSS 对 Cookies 的劫持 CSP 防止插入来历不明的脚本 输入检查 输出检查 CSRF (跨站请求伪造)原理：模拟用户发送请求案例：引诱用户访问某页面，在该页面发送请求，删除用户的博客 防御方法 验证码：即需要用户确认操作 Referer：验证请求的源 Token：CSRF 的本质是因为请求可预测，如delete=blogId，如果请求需要带上不可预测的 token，CSRF 就没办法了，如delete=blogId&amp;token=tokenId，实现步骤后端把 token 站在 cookie 里，因为 CSRF 只是“请求”伪造，是没办法获得 cookie 的 Cookie 的分类 session cookie：浏览器关闭后失效，没有指定 expire 时生成的 cookie，存于浏览器内存 Third-party cookie：到了 expire 后失效，指定 expire 时生成的 cookie，存于本地！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Udacity 前端学习总结]]></title>
      <url>%2F2017%2F02%2F13%2Fudacity%2F</url>
      <content type="text"><![CDATA[简介：Udacity 前端学习总结 P1 HTML 学习了 &lt;em&gt; 与 &lt;i&gt; 的区别：视觉上都是斜体，但 &lt;em&gt; 表示强调， &lt;i&gt; 是从斜体，从文档中区分出来 &lt;strong&gt; 和 &lt;b&gt; 的区别：视觉上都是粗体，但 &lt;strong&gt; 表示重要，&lt;b&gt; 则是以粗体从文档中区分出来 &lt;mark&gt; 表示搜索结果高亮 用 &lt;del&gt; 表示删除的语义， &lt;strike&gt; 也可以但 HTML 5 不推荐 &lt;sup&gt; 和 &lt;sub&gt; 表示上下标 总结：123456789逃避可耻&lt;em&gt;但&lt;/em&gt;有用&lt;i&gt;我就是斜体表示一下&lt;/i&gt;删除很&lt;strong&gt;危险&lt;/strong&gt;&lt;b&gt;我就是粗体表示一下&lt;/b&gt;搜索结果&lt;mark&gt;高亮&lt;/mark&gt;了 P6 网站优化关键渲染路径将 HTML 转化为 DOM主要流程是 Characters -&gt; Tokens -&gt; Nodes -&gt; Dom 即解析 HTML 的字符，遇到 &lt;&gt; 标签就把它转化为一个令牌（注意令牌有起始、结束令牌之分，以此浏览器可以确定层级关系），另一个进程同时会消耗令牌（同步可以加快渲染速度吧）生成节点对象。当所有令牌消耗完，则 DOM 树也生成完毕 DOM 树表示了 HTML 的内容和属性，以及各节点间的关系。此时每个节点对象包含了 html 上定义的属性，如 img 节点对象包含了 html 上 img 的 src 属性 构建 DOM 是逐步的 将 CSS 转化为 CSSOM 在 Timeline 的 Event Log 的 Rendering 的 Recalculate Style 可以看见应用 style 所用的时间 渲染树 在用 CSSOM 和 DOM 构建渲染树时，是把可见的节点拷贝进渲染树。如 内的元素是不可见的，style 设为 display none 的元素是不可见的，都不会再渲染树中 有些元素虽然不占空间，但是也会存在渲染树中，如 height 为0 的元素，element: before 没有设置 content 的元素， visible 为 hidden 的元素 布局如果没有在 中指定 viewport 大小，浏览器将使用默认的 viewport 大小，如苹果的 980 px 优化关键路径CSS 会阻塞渲染，因为浏览器需要构建完 render 树才会渲染，但不阻塞解析 DOM。但可以通过定义媒体查询 CSS 文件来减少阻塞。 阻塞渲染的 CSS (by google) 有关 JavaScript 依赖的详细信息JS 会阻塞解析。CSS 阻塞 JS 执行，因为 JS 可能会更改 CSSOM，所以浏览器”智能“的等到 CSS 文件下载并构建成 CSSOM 后，才会执行 JS 预加载扫描程序浏览器如何预加载 RAIL Response：100ms, 反馈用户的交互 Animate：60fps, 展示动画，只有这时才需要! Idle：50ms, 利用空闲时间，加载不重要的内容 Load：1000ms, 首屏显示 更改样式像素管道即更改样式时，要经历的 5 个区域 JavaScript（更改样式） 使用 requestAnimationFrame 使用 web worker Style Calculation（样式计算），可分为两个步骤：匹配选择器、根据选择器计算样式 降低选择器复杂度 BEM 减少要计算样式的元素数目 Layout（重排） 使用 flex 布局（比 flow 和 position 高效？！） Paint（重绘） 使用复合层，减少重绘范围 降低样式复杂度如 box-shadow Composite（复合） 使用 transform 和 opacity 来做动画 减少复合层transform: translate(0, 0) 是个 2D translate 不会产生复合层，要 transform: translateZ(0) 表示 3D translate 才会产生复合层 强制同步布局事件该事件的发生是因为，样式发生了改变，浏览器不用同步更新，而是缓存起来批量更新样式。但是如果改变了样式，然后查询样式，则浏览器需要同步布局，才能返回正确的样式1234567// 此时浏览器会强制同步布局，然后才能返回正确的 offsetHeightbox.classList.add('new-style')box.offsetHeight// 正确的做法的，如果不需要查询更新后的样式，可以把查询放在前面box.offsetHeightbox.classList.add('new-style')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LazyMan 知识总结]]></title>
      <url>%2F2017%2F02%2F13%2Flazy-man%2F</url>
      <content type="text"><![CDATA[如何实现一个LazyMan （微信实习面试题） 知识点 使用 setTimeout(this.next, 0)来省略一般 LazyMan 的 value() 方法，控制函数的开始执行 把闭包函数推入 this.tasks 省略对参数的储存（仔细想想，闭包就是用来存参的） 使用 this.tasks 来维护执行顺序：sleepFirst 直接 unshift 先执行，其他用 push 按顺序执行 解析器在全局或者函数内部解析到 function 时，默认认为是函数声明。使用 = 或 () 让解析器以函数表示解析函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高性能滚动（一）：Passive event listeners]]></title>
      <url>%2F2017%2F01%2F15%2Fpassive-event-listeners%2F</url>
      <content type="text"><![CDATA[简介：Passive event listeners 是新增的特性，指在 addEventListener 时传入{passive: true} 参数，表明不会在回调中执行 preventDefault()从而消除由 touch 和 wheel 事件带来的滚动阻塞，提高页面的滚动性能。 目录 问题原因 使用 特性检测 问题原因所有的现代浏览器都有个线程专门用于滚动，保证页面滚动的流畅。但是因为 touchstart, touchmove 和 wheel （注意不包括 scroll 事件，因为 scroll 事件是在页面已经滚动时才触发的）这 3 个事件可以通过调用 preventDefault() 阻止滚动行为。所以如果为滚动元素注册了以上的事件，则浏览器必须等待回调函数执行完毕才能滚动，这无疑影响了滚动性能。而且即使是一个 空的回调函数也会影响滚动性能。 根据Google统计 For instance, in Chrome for Android 80% of the touch events that block scrolling never actually prevent it. 10% of these events add more than 100ms of delay to the start of scrolling, and a catastrophic delay of at least 500ms occurs in 1% of scrolls. 所以 Passive event listeners 就是提供给我们一个方法，在用 addEventListener 注册 touchstart, touchmove 和 wheel 监听器时，承诺我们不会调用 preventDefault(), 让浏览器不需等待回调执行，马上开始滚动。 使用12// passive touchstart eventtarget.addEventListener(&apos;touchstart&apos;, listener, &#123;passive: true&#125;) MDN addEventListener也已经更新了该语法 特性检测由于旧版本的浏览器 addEventListener 的第三个参数是接受一个布尔值的，如果传对象进去，只会被解析为 true，所以在注册时需要检测是否支持该特性，可以通过 detect-passive-events 库检测]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm模块开发问题总结]]></title>
      <url>%2F2017%2F01%2F15%2Fnpm-module%2F</url>
      <content type="text"><![CDATA[简介：总结在开发 npm 模块过程遇到的一些问题 目录 LICENSE 导出模块 命名冲突 LICENSE在初始化 npm 时需要指定开源协议，当时还各种找模板，其实在 github 创建新的仓库时就可以指定生成了，也有 简单的介绍 导出模块在导出 npm 模块时，一开始我很天真的使用 ES6 的语法（还没被实现的语法，我怎么想的，真是笑死我了）1export default myFunction 再了解到 Webpack 同时支持 CommonJS 和 AMD 方案后，决定使用 AMD 方案。结果 create-react-app 又不支持 AMD 所以最后使用了 UMD 的 returnExports 兼 Node, AMD 和 browser globals 3 种使用方式，顺便整理了 JS 模块的规范： AMDRequireJS使用的方案12345678// define暴露define(function() &#123; // 返回想要暴露的对象 return objectYourWantToExport&#125;)// require引入require([module], callback) CommonJSNodeJS使用的方案12345// exports暴露module.exports = jquery// require引入var $ = require('jquery') UMDUMD github 通用模块规范用于适配各种场景 命名冲突 使用 npm publish 可以发布模块，但在发布 npm 模块时出现 permission 错误，还以为是哪一步错了，结果是包的命名冲突了，更改 package.json 中的 name 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性访问检测]]></title>
      <url>%2F2017%2F01%2F08%2Fsnooper%2F</url>
      <content type="text"><![CDATA[简介：发现定义 Object.defineProperty 的 getter 方法可以做很有意思的事，适合做浏览器的兼容性检测，特此记录一下 事情是这样的，为了优化浏览器的滚动体验， addEventListener 的第三个参数可以传一个包含 passive 属性的对象，表明该事件是 passive 的（具体可以看Passive Event Listener）。但是为了兼容旧版本的浏览器，就需要探测浏览器浏览器是否接受一个包含 passive 属性的对象。那么怎么探测呢？具体代码如下12345678910111213// Test via a getter in the options object to see if the passive property is accessedvar supportsPassive = false;try &#123; var opts = Object.defineProperty(&#123;&#125;, 'passive', &#123; get: function() &#123; supportsPassive = true; &#125; &#125;); window.addEventListener("test", null, opts);&#125; catch (e) &#123;&#125;// Use our detect's results. passive applied if supported, capture will be false either way.elem.addEventListener('touchstart', fn, supportsPassive ? &#123; passive: true &#125; : false); 自定义对象的属性和 getter 方法，如果被检测的函数使用了该属性，那么必定会调用 getter 方法，这样就能判断浏览器是是支持该特性的，真是巧妙到没有朋友啊！ 总结 使用场景：检测是否访问过对象的某属性 使用方法：通过 Object.defineProperty 自定义 getter 方法来检测 原理：如果访问该属性，则会调用 getter 方法 自测题目 检测函数 say 是否支持接受 name 属性和 test 属性123function say(person) &#123; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; old`)&#125; 答案12345678910111213141516171819202122232425function say(person) &#123; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; old`)&#125;let isSupportName = falsetry &#123; const snooper = Object.defineProperty(&#123;&#125;, 'name', &#123; get() &#123; isSupportName = true &#125; &#125;) say(snooper)&#125;catch(e) &#123;&#125;let isSupportTest = falsetry &#123; const snooper = Object.defineProperty(&#123;&#125;, 'test', &#123; get() &#123; isSupportTest = true &#125; &#125;) say(snooper)&#125;catch(e) &#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手Q演出选座页性能10倍提升的优化]]></title>
      <url>%2F2017%2F01%2F02%2Fcanvas-seat%2F</url>
      <content type="text"><![CDATA[简介：本文将会分析在使用React时，面对多组件（如1K个组件）的初始化渲染，和单组件更新的场景，可以使用的优化思路 目录 前提 场景 Single Connect 方案 Multiple Connect 方案 Smart Seat 方案 Canvas Seat 方案 总结 前提 本文测试时所使用库的版本如下1234567891011"dependencies": &#123; "classnames": "^2.2.5", "react": "^15.4.0", "react-dom": "^15.4.0", "react-redux": "^4.4.6", "react-router": "^3.0.0", "redux": "^3.6.0", "redux-logger": "^2.7.4", "redux-thunk": "^2.1.0", "reselect": "^2.5.4"&#125; 场景在我们演出项目的选座页，需要展示演出的座位，并且在用户选择某一座位后，要更新该座位的视图。为了简化问题，在这里抽象一下模型，即有 Seats 和 Seat 两个组件 Seats 从 store 中接收一个包含 1000 个包含座位信息的 seat 元素的数组 seats ，然后渲染 Seat 组件 Seat 组件被点击后，变更该组件颜色 Single Connect 方案Single Connect方案 ，这是我们最开始的方案，只在 Seat 组件内定义 shouldComponentUpdate 减少不必要的 render 性能及分析 iphone7 小米 初始渲染时间 40ms 474ms 组件更新时间 70ms 123ms 此时性能瓶颈主要有 2 点：每次更新时 Seats 组件都需要渲染；数据需要从 store 经过 Seats 最终才能传递给对应的 Seat 组件。后面优化也是针对这 2 点进行的 Multiple Connect 方案Multiple Connect方案是参考 Dan 神提出的 分离数据 思想，来减少不必要的 render 实现思想：在每次更新时，其实 Seats 是不需要 render 的，真正需要 render 的只有那个被点击的 Seat 实现方式： Seats 组件只关心要渲染多少个 Seat 组件，即从 seats 数组中分离出 seatIds 表示每个元素的 index，然后 Seats 组件根据 seatIds 来 map，注意因为每次更新 seatIds 是不会变的，所以可以 减少 Seats 的渲染 Seat 组件只关心自己的状态，Seat 组件也 connect store，并且根据 Seats 传进来的 id 来从 seats 数组中获得自己对应的 seat 数据 性能及分析 iphone7 小米 初始渲染时间 103ms 1700ms 组件更新时间 8ms (8x) 17ms (7x) 组件更新性能平均提升了7x左右，因为此时减少了 Seats 组件的渲染，且数据直接从 store 通过 connect 传递给对应的 Seat 组件。但是 Seat 组件需要在初始化时 subscribe store，所以增加了初始渲染时间 Smart Seat 方案Smart Seat方案的主要思想是：把 Seat 由单纯的展示型组件，变成功能型组件，由每个 Seat 来管理自己的状态 实现方式如下：在 Seat 组件被点击时，dispatch action 然后在回调里 setState 触发组件更新12345678onClick = id =&gt; &#123; this.props.selectSeat(id) .then(selectSuccess =&gt; &#123; this.setState(&#123; selected: selectSuccess, &#125;) &#125;)&#125; 性能及分析 iphone7 小米 初始渲染时间 41ms 478ms 组件更新时间 9ms (8x) 5ms (24x) 此时不但减少 Seats 组件的渲染，且数据也绕过 store 直接从 actions 的回调中获得，使得组件更新性能平均提升了 16x 左右 Canvas Seat 方案Canvas Seat方案的思想是使用 canvas 来绘制座位和更新对应座位，这样就可以不用渲染那么多 Seat 节点，只渲染一个 canvas 节点即可，规避 dom 慢的缺陷。且更新不发生 render，只是重绘对应位置的座位，省去 Seats 组件的渲染 实现方式：在 Seats 组件只 render 一个 canvas 节点，并在 componentDidMount 后绘制座位 性能及分析 iphone7 小米 初始渲染时间 4.3ms (9x) 42ms (12x) 组件更新时间 3.7ms (18x) 10ms (12x) 初始时减少大量节点的渲染，初始化性能惊人的提升了 10x。更新组件时，也只是重新绘制一个座位，组件更新性能也得到了极大的 18x的提升 总结在摸索 React 性能优化的过程中，越发的理解前端的性能瓶颈不在 JS，而在 dom 的操作。我曾尝试过各种方法减少数组的遍历，更高效的取整（ ~~ 替代 parseInt ），但效果都是微乎其微。而每一次减少组件的 render，却能给性能带来成倍的提升，如 Multiple Connect 和 Smart Seat 方案中，减少 Seats 组件的渲染带来了 5x 的提升。Canvas Seat 方案中，减少了 999 个组件的渲染（1 个 canvas 代替 1000 个 Seat ），带来 10x 的性能提升！ 而且，另一个让我感受很深的就是，除了 Multiple Connect 方案是根据 Dan 神提出的思想实现的，其余 2 个方案都是我们手Q队员提出的，而且性能都比 Dan 神的方案好！这让我学习到，作为一个程序员，能因地制宜，发挥自己的 想象力 提出更针对性的方案更重要]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原型继承]]></title>
      <url>%2F2016%2F12%2F31%2Fprototype-inheritance%2F</url>
      <content type="text"><![CDATA[简介：学习原型继承的原理 目录 术语 原型继承的使用场景 原型继承的使用方法 原理 术语 Constructor：泛指构造函数 Class：泛指类 instance：泛指实例 原型对象：prototype属性的值 使用场景想要使对象拥有 新属性 ，而该属性是在其原型链上的若不介意是在其原型链上，还是在其本身，则为该对象赋值即可 使用方法 用new关键字调用构造函数，使实例原型继承该构造函数 12345function Person() &#123;&#125;Person.prototype.sayHi = function ()&#123;&#125;// person原型继承Personconst person = new Person()console.log(person.sayHi) 用extends关键字，使一个类原型继承另一个类 1234567891011class Person &#123; sayHi() &#123;&#125;&#125;// Student原型继承Personclass Student extends Person &#123; study() &#123;&#125;&#125;// student原型继承Studentconst student = new Student()console.log(student.sayHi)console.log(student.study) 原理在了解原理前，先了解2个关键的知识点：prototyoe属性，和proto属性 prototype属性prototype属性只存在于构造函数的属性中，其值为一个对象，该对象用于储存其所有实例共享的属性和方法。（以后称该对象为原型对象） 类比：只有一代宗师（构造函数），才有用于记录自己招式的武功秘籍（原型对象），而其所有徒弟（实例），都能访问到武功秘籍上的招式（属性） proto属性proto属性存在于每个对象中，值为该对象的原型好吧，其实null对象没有proto属性，但咱先忽略 类比：每个人（对象），都有一条链子（proto）。链子的另一端，绑着其师傅（构造函数）的武功秘籍（原型对象） 原型继承原理访问对象的属性时，如果在对象上找不到指定属性，则不断在对象的proto上查找，一直到原型链最顶层都没找到，则返回undefined 假设当前实例为instance，在instance上找不到，则会在instance.proto上找，再找不到，则在instance.proto.proto上找，一直到Object.prototype.proto也就是null都没找到，则返回undefined 题外话在JavaScript世界中。构造函数Object原型继承null，Function原型继承Object，最后Function实例出能实例千千万的构造函数function。12345678910console.log(Object.prototype.__proto__ === null)// true, Object继承nullconsole.log(Function.prototype.__proto__ === Object.prototype)// true，构造函数Function继承Objectfunction P()&#123;&#125;console.log(P.__proto__ === Function.prototype)// true，构造函数P，是构造函数Function的实例const p = new P()console.log(p.__proto__ === P.prototype)// true，实例p，是构造函数P的实例 实例原型继承构造函数的原理在使用new关键字调用构造函数时，JS自动把实例的proto属性指向构造函数的prototype对象1234567function Person() &#123;&#125;const person = new Person()// 等价于function Person() &#123; // this.__proto__ = Person.prototype // return this&#125; 构造函数继承构造函数的原理123class Student extends Person &#123;&#125;// 等价于Student.prototype.__proto__ = Person.prototype]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构造函数]]></title>
      <url>%2F2016%2F12%2F25%2Fconstructor%2F</url>
      <content type="text"><![CDATA[简介：本文介绍了构造函数，构造函数的prototype属性，构造函数的prototype.constructor属性的应用场景和使用方式。在ES6新增的类的对应使用方式 目录 术语 构造函数 prototype属性 constructor属性 类 总结 自测题目 术语 Constructor：构造函数 instance：实例 构造函数:ConstructorJavaScript中用new关键字调用的就是构造函数123456789function Person(age) &#123; this.age = age this.say = function() &#123; // 实例能访问this.age，this就是实例自己 console.log(`My age is $&#123;this.age&#125;`) &#125;&#125;const p = new Person(18)p.say() 原理：使用new调用构造函数时，其函数体定义的this会默认返回作为实例 应用场景：定义私有属性和方法 使用方式：在构造函数的函数体内的this定义。如上所示，为this定义age属性和say方法，即可使其实例拥有对应的私有属性和方法 prototype属性：Constructor.prototype每个构造函数都有一个prototype属性，其值为一个对象（以后称prototype所指的对象为原型对象） 原型对象的用途，是储存其所有实例共享的属性和方法。《JavaScript高级程序设计》P147 12345678function Person() &#123;&#125;Person.prototype.age = 18Person.prototype.say = function() &#123; // 实例能访问this.age，是因为age是实例的原型属性，在其原型链上 console.log(`My age is $&#123;this.age&#125;`)&#125;const p = new Person()p.say() 原理：实例继承构造函数的原型对象，所以能通过原型链访问 应用场景：定义共享属性和方法 使用方式：在构造函数的原型对象上定义。如上所示，为Person.prototype定义age属性和say方法，即可使所有实例都拥有对应的共有属性和方法 constructor属性：Constructor.prototype.constructor 所有原型对象都会自动获得一个constructor属性，指向prototype属性所在的构造函数。《JavaScript高级程序设计》P148 12345678function Person() &#123;&#125;Person.age = 18Person.say = function() &#123; // 注意，此时还能用this，访问this.age console.log(`My age is $&#123;this.age&#125;`)&#125;const p = new Person()p.constructor.say() 原理：构造函数也是对象，能定义自己的属性和方法（称为静态属性和方法） 应用场景：定义默认属性，如React的defaultProps。和校验方法如Array.isArray 使用方式：直接在构造函数这个对象上定义。如上所示Person.name，然后调用时通过p.constuctor.say。因为实例是继承构造函数的原型对象，而不是继承构造函数 类ES6新增了class关键字，允许我们定义类。但其实class只是构造函数的语法糖而已123456789101112class Person &#123; // 等价于Person.staticSay = function()&#123;&#125; static staticSay() &#123;&#125; constructor(age) &#123; this.age = age // 等价于this.instanceSay = function()&#123;&#125; this.instanceSay = function()&#123;&#125; &#125; // 等价于Person.prototype.prototypeSay = function()&#123;&#125; prototypeSay() &#123;&#125;&#125;const p = new Person() 其中加了static关键字的方法，相当于构造函数的静态方法，constructor相当于构造函数的函数体，而非constructor的其余方法，则相当于构造函数的原型方法 总结 Constructor的函数体是定义实例的实例属性和方法的 Constructor.prototype是定义实例的共享属性和方法的 Constructor上是定义构造器的静态属性和方法的 类知识构造函数的语法糖 自测题目 声明一个构造函数Student，使得该构造函数产生的实例 有私有的name属性和study方法 有共有的school属性和say方法 有静态属性defaultProps和用于校验是否Student实例的isStudent方法 使用类完成上述功能 答案123456789101112131415161718192021function Student(name) &#123; this.name = name this.study = function() &#123; console.log('unique study method') &#125;&#125;Student.prototype.shcool = 'MIT'Student.prototype.say = function() &#123; console.log('common say method')&#125;Student.defaultProps = 'student'Student.isStudent = function(instance) &#123; return instance instanceof Student&#125;const joe = new Student('joe')console.log(joe.name) // joejoe.study() // unique study methodconsole.log(joe.shcool) // MITjoe.say() // common say methodconsole.log(Student.isStudent(joe)) // true]]></content>
    </entry>

    
  
  
</search>
